
---
title: "Univariate analysis"
format:
  html:
    self-contained: true
    theme: flatly
    page-layout: article
    toc: true
    toc-location: left
    toc-depth: 3
    smooth-scroll: true
execute:
  echo: false
  warning: false
  message: false
editor: source
---

# Input data

Caricare le librerie e le funzioni necessarie

```{r loadin-libreries, echo=FALSE}
library(data.table)
library(janitor)
library(here)
library(dplyr)
library(stringr)
library(echarts4r)
library(reactable)
library(htmltools)
library(ComplexHeatmap)
library(clusterProfiler)
library(org.Hs.eg.db)
library(gt)
library(visNetwork)
library(ggplot2)
library(vsn)
library(corrmorant)

source(file = here::here("r6class_app.R"))

# generare l'oggetto
r6 <- QProMS$new()
```

caricare il proteinGroups.txt, inserire il path completo.
Scopo della funzione: caricare il file e modificarlo (rimuovere gli spazi e i caratteri che potrebbero creare problemi nell'analisi)

```{r loading-data}
# r6$loading_data(
#   input_path = here::here("proteinGroups.txt"),
#   input_type = "max_quant"
# )

# loading_data <- function(input_path, input_type){
      
raw_data <- data.table::fread(input = here::here("proteinGroups.txt")) %>% #Carica file 
tibble::as_tibble(.name_repair = janitor::make_clean_names) #Modifica file: il nome delle colonne senza spazi e con minuscolo
      
input_type <-  "max_quant"

    # }
```

Questa funzione crea l'experimental design, ma il proteinGroups.txt deve essere creato con la colonna experiment in MaxQuant impostata come:

condA_1
condA_2
condA_3
condB_1
condB_2
condB_3

Data <- Partendo dal raw_data alla funzione viene detto di cercare tutte le variabili che iniziano con un dato pattern (dplyr::starts_with) a tutte le colonne (dplyr""across), modificando la tabella (mutate).
log2?
dplyr::na_if viene usato per sostituire tutti i valori non significativi con NA

ExpDesign <- partendo da data, prima sono selezionate le colonne di interesse (gene_names e quelle che iniziano con il pattern). Poi con pivot_longer vengono create due nuove colonne (key riporta i vari lfq, mentre intensity i valori corrispondenti)
NB: le intensities sono i log2 di ? Le NA sono quelle che rispettavano la condizione data da na_if?

"distinct" permette di isolare una colonna della tabella (in questo caso key). A questo viene aggiunta una nuova colonna tramite mutate (la colonna label). Questa colonna si definisce tramite stringr::str_remove, che ha lo scopo di rimuovere "lfq..." dalla colonna key per dare come output il contenuto della colonna label.
Con lo stesso apporccio si creano altre due colonne: condition e replicate.


```{r make-expdesig}
# r6$make_expdesign(
#   start_with = "lfq_intensity_bc_"
# )

# make_expdesign <- function(start_with = "lfq_intensity_"){
      ## qui mettere tutti gli if in base all'intensity type
      
intensity_type <- "lfq_intensity_bc_"
      
data <- raw_data %>% 
        dplyr::mutate(dplyr::across(dplyr::starts_with("lfq_intensity_bc_"), ~ log2(.))) %>%
        dplyr::mutate(dplyr::across(dplyr::starts_with("lfq_intensity_bc_"), ~ dplyr::na_if(.,-Inf)))
      
expdesign <- data %>%
  dplyr::select(gene_names, dplyr::starts_with("lfq_intensity_bc_")) %>%
  tidyr::pivot_longer(!gene_names, names_to = "key", values_to = "intensity") %>%
  dplyr::distinct(key) %>%
  dplyr::mutate(label = stringr::str_remove(key, "lfq_intensity_bc_")) %>%
  dplyr::mutate(condition = stringr::str_remove(label, "_[^_]*$")) %>%
  dplyr::mutate(replicate = stringr::str_remove(label, ".*_"))
      
    # }
```

# Data Wrangling

questa funzione serve per filtrare il proteinGroups.txt
con i primi parametri si gestisce il numero di valid values e le opzioni che si possono scegliere sono:

alog = at least one group
each_grp = in each group
total = in total

i secondi 2 parametri servono per filtrare i peptidi, si possono usare le seguenti colonne:

peptides = peptides column
unique = unique columns
razor = razor and unique column

gli ultimi 3 filtano via (con TRUE) i potential contaminant, gli only identify by side e i reverse

```{r data-wrangling}
#r6$pg_preprocessing()

# pg_preprocessing = function(){
      ########################################################################
      #### This function prepare the protein groups in the QProMS format ####
      #### and remove duplicates.                                         ####
      ########################################################################
      
      ### this first part remove duplicate and missing gene names
      ### in proteinGroups.txt input
      
      ## Indentify all duplicate gene names 
      ## and add after __ the protein iD
      
      
# self$define_colors()

 # define_colors <- function(){
      n_of_color <- max(expdesign %>% dplyr::count(replicate) %>% dplyr::pull(n))
      color_palette <- viridis::viridis(n = n_of_color , direction = -1, end = 0.70, begin = 0.30)
    # }
 

      
      define_tests <- function(){
      conditions <-
        dplyr::distinct(self$expdesign, condition) %>% pull(condition)
      
      tests <-
        tidyr::expand_grid(cond1 = conditions, cond2 = conditions) %>%
        dplyr::filter(cond1 != cond2) %>%
        dplyr::mutate(test = paste0(cond1, "_vs_", cond2)) %>%
        dplyr::pull(test)
      
      return(tests)
    }
      
#Partendo da data seleziono 3 colonne (select). Modifico gene_names rimuovendo simboli (stringr::str_extract) e facendo in modo di avere soloo un gene name per ogni proteinID. Rename permette di cambiare il nome della colonna.
#Con janitor::getdupes identifico i gene_names che hanno lo stesso valore.
#tutte le colonne rimaste senza gene_names sono rimpiazzate facendo copia incolla delle proteinID.
#Con right_joint unisco il file data alle due colonne che ho selezionato
  
      
       
data_standardized <- data %>% 
  dplyr::select(protein_i_ds, gene_names, id) %>%
  dplyr::mutate(gene_names = stringr::str_extract(gene_names, "[^;]*")) %>%
 ## every protein groups now have only 1 gene name associated to it
  dplyr::rename(unique_gene_names = gene_names) %>%
  janitor::get_dupes(unique_gene_names) %>%
  dplyr::mutate(unique_gene_names = dplyr::case_when(
  unique_gene_names != "" ~ paste0(
  unique_gene_names, "__",
  stringr::str_extract(protein_i_ds, "[^;]*")),
   TRUE ~ stringr::str_extract(protein_i_ds, "[^;]*")
           )) %>%
        dplyr::select(unique_gene_names, id) %>%
        dplyr::right_join(data, by = "id") %>%
        dplyr::mutate(
          gene_names = dplyr::case_when(unique_gene_names != "" ~ unique_gene_names,
                                        TRUE ~ gene_names)
        ) %>%
        dplyr::select(-unique_gene_names) %>%
        dplyr::mutate(gene_names = dplyr::if_else(
          gene_names == "",
          stringr::str_extract(protein_i_ds, "[^;]*"),
          gene_names
        )) %>%
        dplyr::mutate(gene_names = stringr::str_extract(gene_names, "[^;]*")) %>% 
        dplyr::select(
          gene_names,
          dplyr::all_of(expdesign$key),
          peptides,
          razor_unique_peptides,
          unique_peptides,
          reverse,
          potential_contaminant,
          only_identified_by_site
        ) %>% 
        tidyr::pivot_longer(
          !c(gene_names,
             peptides,
             razor_unique_peptides,
             unique_peptides,
             reverse,
             potential_contaminant,
             only_identified_by_site),
          names_to = "key",
          values_to = "raw_intensity"
        ) %>% 
        dplyr::inner_join(., expdesign, by = "key") %>%   #aggiunge righe e colonne che matchano tra expdesign e data
        dplyr::mutate(bin_intensity = dplyr::if_else(is.na(raw_intensity), 0, 1)) %>%  #Creo nuova colonna. 1 se valore esite, 0 se NA
        dplyr::select(-key)
      
      # self$data <- data_standardized
#    }

# r6$data_wrangling(
#   valid_val_filter = "alog",
#   valid_val_thr = 0.75,
#   pep_filter = "peptides",
#   pep_thr = 2,
#   rev = TRUE,
#   cont = TRUE,
#   oibs = TRUE
# )

#data_wrangling <- function(valid_val_filter = "alog", valid_val_thr = 0.75,
#                          pep_filter = "peptides", pep_thr = 2,
#                          rev = TRUE, cont = TRUE, oibs = TRUE, rescue_cont = NULL) 
       
      ##############################################################
      #### this function is divided in 2 steps:                 ####
      #### the first apply filer specific to maxquant input.    ####
      #### the second part filer the data base on valid values. ####
      ##############################################################
      
      # data <- self$data 

pep_filter = "peptides" 
pep_thr = 2
rev = TRUE
cont = TRUE
oibs = TRUE

        ### pep filter puo essere:
        ## c("peptides", "unique", "razor")
        
        data_wrang <- data_standardized %>% 
            # dplyr::mutate(potential_contaminant = dplyr::case_when(
            # gene_names %in% rescue_cont ~ "", TRUE ~ potential_contaminant)) %>% #Mette "" per ogni gene_names che si trova in rescue_cont
          ## remove reverse, potentialcontaminant and oibs from data base on user input
          {if(rev)dplyr::filter(., !reverse == "+") else .} %>%
          {if(cont)dplyr::filter(., !potential_contaminant == "+") else .} %>%
          {if(oibs)dplyr::filter(., !only_identified_by_site == "+") else .} %>% 
          ## filter on peptides:
          {if(pep_filter == "peptides"){dplyr::filter(., peptides >= pep_thr)}
            else if (pep_filter == "unique") {dplyr::filter(., unique_peptides >= pep_thr)}
            else {dplyr::filter(., razor_unique_peptides >= pep_thr)}}

#Quello sopra ma scritto in versione estesa per tutte le condizioni
# data_wrang <- data %>%
# if(cont == TRUE) {
#   dplyr::filter(data, potential_contaminant == "")
#   } else{
#   data
# } %>%
#   if(rev==TRUE) {
#     dplyr::filter(data, !reverse=="+")
#     } else {
#   data
# } %>%
#   if(oibs==TRUE) {
#     dplyr::filter(data, !only_identified_by_site=="+")
#     } else {
#     data
# } %>%
# 
# if(pep_filter == "peptides") {
#   dplyr::filter(data, peptides >= 2)
# } else if(pep_filter == "unique"){
#   dplyr::filter(data, unique_peptides >= 2)
# }else{
#   dplyr::filter(data, razor_unique_peptides >= 2)
# } 
  
valid_val_filter = "alog"
valid_val_thr = 0.75

filtered_data <- data_wrang %>%
        {if(valid_val_filter == "total")dplyr::group_by(., gene_names)
          else dplyr::group_by(., gene_names, condition)} %>% 
        dplyr::mutate(miss_val = dplyr::n() - sum(bin_intensity)) %>% 
        dplyr::mutate(n_size = dplyr::n()) %>%
        dplyr::ungroup() %>%
        dplyr::group_by(gene_names) %>%
        ## rage compreso tra 0 e 100% espresso in valori tra 0 e 1
        {if(valid_val_filter == "alog") dplyr::filter(., any(miss_val <= round(n_size * (1 - valid_val_thr), 0)))
          else dplyr::filter(., all(miss_val <= round(n_size * (1 - valid_val_thr), 0)))} %>%
        dplyr::ungroup() %>%
        dplyr::select(gene_names, label, condition, replicate, bin_intensity, raw_intensity) %>% 
        dplyr::rename(intensity = raw_intensity)
      
```

questo grafico mostra il risultato dei filtri sopra selezionati

```{r protein-counts}
# r6$plot_protein_counts() 
# plot_protein_counts = function(){
      
      # controllare che ci sia il self$filtered_data
      # data <- self$filtered_data
      # expdes <- self$expdesign
p <- filtered_data %>%
        dplyr::group_by(label) %>%
        dplyr::summarise(counts = sum(bin_intensity)) %>%
        dplyr::ungroup() %>%
        dplyr::inner_join(., expdesign, by = "label") %>%
        dplyr::mutate(replicate = as.factor(replicate)) %>%
        dplyr::group_by(condition) %>% 
  #Costruzione del grafico
        echarts4r::e_charts(replicate, renderer = "svg") %>%
        echarts4r::e_bar(counts) %>%
        echarts4r::e_x_axis(name = "Replicates") %>%
        echarts4r::e_y_axis(name = "Counts") %>%
        echarts4r::e_tooltip(trigger = "item") %>%
        echarts4r::e_color(color_palette) %>%
        echarts4r::e_theme("QProMS_theme") %>% 
        echarts4r::e_y_axis(
          name = "Counts",
          nameLocation = "center",
          nameTextStyle = list(
            fontWeight = "bold",
            fontSize = 16,
            lineHeight = 60
          )
        ) %>%
        echarts4r::e_x_axis(
          name = "Replicate",
          nameLocation = "center",
          nameTextStyle = list(
            fontWeight = "bold",
            fontSize = 14,
            lineHeight = 60
          )
        ) %>% 
        echarts4r::e_toolbox_feature(feature = c("saveAsImage", "restore", "dataView"))
      
    #   return(p)
    # }
```

```{r protein-counts-static}
p <- filtered_data %>%
        dplyr::group_by(label) %>%
        dplyr::summarise(counts = sum(bin_intensity)) %>%
        dplyr::ungroup() %>%
        dplyr::inner_join(., expdesign, by = "label") %>%
        dplyr::mutate(replicate = as.factor(replicate)) %>%
        dplyr::group_by(condition)

 n_of_color <- max(expdesign %>% dplyr::count(replicate) %>% dplyr::pull(n))
      color_palette <- viridis::viridis(n = n_of_color , direction = -1, end = 0.70, begin = 0.30)

      
       
ggplot(p,aes(x= label, y= counts, fill=condition))+
  geom_bar(stat="identity", width = 0.6, color="black")+
  scale_fill_manual(values = color_palette)+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5, size = 18), 
        legend.position = 'right',
        axis.title.x = element_text(size=15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size=10, angle = 30),
        axis.text.y = element_text(size = 10))+
  labs(title= "Protein counts by condition")+
  geom_text(aes(label=counts), vjust=-0.2, size=4) 


  #geom_label(aes(label=counts), fill="white", vjust=-0.2, size=4, fontface="bold")

             
```


```{r valid-values}
r6$plot_protein_coverage()

plot_protein_coverage = function(){
      
      # controllare che ci sia il self$filtered_data
      data <- self$filtered_data
      
      p <- data %>%
        dplyr::group_by(gene_names) %>%
        dplyr::summarise(counts = sum(bin_intensity)) %>%
        dplyr::ungroup() %>%
        dplyr::select(counts) %>%
        table() %>%
        tibble::as_tibble() %>%
        dplyr::rename(occurrence = n) %>%
        echarts4r::e_charts(counts, renderer = "svg") %>%
        echarts4r::e_bar(occurrence) %>%
        echarts4r::e_y_axis(name = "Counts") %>%
        echarts4r::e_tooltip(trigger = "item") %>%
        echarts4r::e_color(self$color_palette) %>%
        echarts4r::e_theme("QProMS_theme") %>% 
        echarts4r::e_y_axis(
          name = "Counts",
          nameLocation = "center",
          nameTextStyle = list(
            fontWeight = "bold",
            fontSize = 16,
            lineHeight = 60
          )
        ) %>% 
        echarts4r::e_toolbox_feature(feature = c("saveAsImage", "restore", "dataView"))
      
      return(p)
    }
```

```{r Plot_protein_coverage_static}
 p1 <- filtered_data %>%
        dplyr::group_by(gene_names) %>% 
        dplyr::summarise(counts = sum(bin_intensity)) %>%
        dplyr::ungroup() %>%
        dplyr::select(counts) %>%
        table() %>%
        tibble::as_tibble() %>%
        dplyr::rename(occurrence = n)
p1_1<- p1{\}
ggplot(p1,aes(x= occurrence, y= counts))+
  geom_bar(stat="identity", width = 0.6, color="black", fill="#21908CFF")+
  # scale_y_reverse()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5, size = 18), 
        axis.title.x = element_text(size=15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size=10),
        axis.text.y = element_text(size = 10))+
  labs(title= "Protein coverage")+
  geom_text(aes(label=occurrence), hjust=-0.3, size=4)

```


```{r cv}
r6$plot_cv()
    plot_cv = function(){
      
      # controllare che ci sia il self$filtered_data
      data <- self$filtered_data
      
      p2 <- filtered_data %>% 
        dplyr::group_by(gene_names, condition) %>% 
        dplyr::summarise(
          mean = mean(intensity, na.rm = TRUE),
          sd = sd(intensity, na.rm = TRUE),
          CV = round(sd / mean, 3)
        ) %>% 
        dplyr::ungroup() %>% 
        dplyr::group_by(condition) 
      
        echarts4r::e_chart() %>% 
        echarts4r::e_boxplot(
          CV,
          colorBy = "data",
          outliers = FALSE,
          itemStyle = list(color = "#DADADA", borderWidth = 2)
        ) %>%  
        echarts4r::e_tooltip(trigger = "axis") %>% 
        echarts4r::e_title(text = "Sample CV", subtext = "Coefficient of variation") %>% 
        echarts4r::e_color(self$color_palette)
      
      return(p)
    }

```

ora bisogna verificare che le distribuzioni siano normali 

# Normalization

```{r plot-dis}
r6$plot_distribution()
```

nel caso le distribuzioni non siano normali, è possibile noralizzarle con la seguente funzione:
per ora c'è solo l'opzione con la vsn

```{r norm}
r6$normalization(norm_methods = "None")
```

# Missing data

ora bisogna decidere come imputare i missing data rimanenti, utilizzare i seguenti plot per decidere:

```{r plot-missval1}
r6$plot_missing_data()
```

```{r plot-missval2}
r6$plot_missval_distribution()
```

```{r plot-missval3}
r6$plot_imputation()
```

# Imputation

per imputare i dati usare la seguente funzione, si puo scegliere tra mixed e perseus

```{r imp}
r6$imputation(
  imp_methods = "mixed",
  shift = 1.8,
  scale = 0.3, 
  unique_visual = FALSE
)
```

per vedere l'effetto dell'imputazione

```{r plot-imputation}
r6$plot_imputation()
```

# Correlation plot

```{r plot-corr}
r6$plot_correlation_interactive()
```

```{r plot-corr-static}
r6$plot_correlation_static(cor_method = "pearson")
```

# PCA plot

```{r pca}
r6$plot_pca(view_3d = FALSE)
```

# statistics

specificare il test o i test che si vogliono attuare.
la struttura da mettere nel test è sempre formata da:
condA_vs_condB

```{r tests}
## single test format
tests <- "rev_vs_dmso"

## multiple test format
# tests <- c("rev_vs_dmso", "rev_vs_nw")

## se si vuole una lista di tutte le possibili conbinazioni usare la seguente funzione:
r6$define_tests()
```

è possibile cambiare i parametri come si desidera.
raccomando di utilizzare sempre il dataset imputato come di default, ma volendo si puo usare anche quello con i missing data che si chiama:
r6$normalized_data

```{r uni-single}
r6$stat_t_test(
  data = r6$imputed_data,
  test = tests,
  fc = 1,
  alpha = 0.05
)
```

per vedere la tabella risultate per adesso non ho creato una funzione, ma ecco come visualizzarla:

```{r result-table}
r6$stat_table %>% View()
```

volcano plot:
se si vuole vedere un gene in particolare o una lista di geni sostituire il NULL in highlights_names con il gene di interesse

```{r plot-volcano}
r6$plot_volcano(test = tests, highlights_names = c("VCAN", "STAT3"))
```

# Functional analysis

## ORA

o possibile selezionare BP per biological process, CC per cellular component e MF per molecolar funtions.
il parametro max_row determina quanto deve essere grande al massimo il risultato finale, più è piccolo il numero meno sono ridondanti i termini e viceversa.

```{r ora}
ora_go_bp <-
  r6$go_ora(
    org_db = org.Hs.eg.db,
    ontology = "BP",
    alpha = 0.05,
    max_row = 20
  )
```

plot ora:

```{r plot-ora}
r6$plot_ora(ora_go_bp, test = tests)
```

## GSEA

```{r gsea}
gsea_go_bp <-
  r6$gsea_go(
    org_db = org.Hs.eg.db,
    ontology = "BP",
    pvalue_cutoff = 0.05,
    max_row = 20
  )
```

plot gsea:

```{r}
r6$plot_gsea(gsea_go_bp, test = tests)
```

# Network analysis

non posso mettere questa parte in una funzione, ma il codice è abbastanza esplicativo:

```{r net-single, echo=FALSE}
visNetwork(
  nodes = r6$make_nodes(ora_table = ora_go_bp, test = tests),
  edges = r6$make_edges(ora_table = ora_go_bp, test = tests),
  height = "700px",
  width = "100%"
) %>%
  visIgraphLayout(layout = "layout_nicely", randomSeed = 1) %>%
  visOptions(
    selectedBy = list(variable = "group"),
    highlightNearest = list(
      enabled = TRUE,
      degree = 1,
      hover = TRUE
    ),
    nodesIdSelection = TRUE
  ) %>%
  visPhysics(stabilization = TRUE) %>%
  visEdges(smooth = FALSE)
```

