---
title: "New Univariate Analysis"
format: html
editor: visual
warning: false
editor_options: 
  chunk_output_type: console
---

## Libraries loading and sources

```{r loading-libreries, echo=FALSE}
library(data.table)
library(janitor)
library(here)
library(dplyr)
library(stringr)
library(echarts4r)
library(reactable)
library(htmltools)
library(ComplexHeatmap)
library(clusterProfiler)
library(org.Hs.eg.db)
library(gt)
library(visNetwork)
library(ggplot2)
library(vsn)
#Ho rimosso in pacchetto corrmorant perchè dava errore su Mac
library(ComplexHeatmap)
library(STRINGdb)
library(igraph)
library(network)
library(qgraph)
library(networkD3)
library(httr)
library(jsonlite)
library(rbioapi)

source(file = here::here("myfun_test.R"))
source(file = here::here("theme_ggplot_test.R"))

source(file = here::here("r6class_app.R"))


r6 <- QProMS$new()

```

## Loading raw data

```{r loading-data-1}
raw_data <- loading_data(file_path = here::here("proteinGroups.txt"))
```

```{r loading-data-2}
r6$loading_data(
  input_path = "proteinGroups.txt",
  input_type = "max_quant"
)
```

## Make Experimental Design

```{r make-expdesign-1}
exp_des <- exp_design (data=raw_data, pattern_interest = "lfq_intensity_bc_")
```

```{r make-expdesign-2}
r6$make_expdesign(
  start_with = "lfq_intensity_bc_"
)
```

## Data pre-processing

```{r Data preprocessing 1}
data_pre <- pre_process (data=raw_data, pattern_interest =  "lfq_intensity_bc_")
```

```{r Data preprocessing 2}
r6$pg_preprocessing()
```

## Data wrangling merged table (exp_des+pre_process)

```{r Wrangling/Data filtered}
data_wrang <- data_wrangling(data=data_pre,
                             pep_filter = "peptides",
                             pep_thr = 2)
```

```{r data-wrangling}
r6$data_wrangling(
  valid_val_filter = "alog",
  valid_val_thr = 0.75,
  pep_filter = "peptides",
  pep_thr = 2,
  rev = TRUE,
  cont = TRUE,
  oibs = TRUE
)
```

## Filter application

```{r Data Filtered}
data_filt <- data_filtered(data = data_wrang,
                           valid_val_filter = "alog",
                           valid_val_thr = 0.75)
```

## Data imputation

```{r Data imputed}
data_imput <- data_imputed (data= data_filt,
                         shift = 1.8, 
                         scale = 0.3, 
                         unique_visual = FALSE)

```

```{r Imputation}
r6$imputation()
```

## Color palette

```{r Palette}
n_of_color <- max(exp_des %>% dplyr::count(replicate) %>% dplyr::pull(n))
color_palette <- viridis::viridis(n = n_of_color , direction = -1, end = 0.70, begin = 0.30)

```

## Quality control

```{r Protein count by condition}
barplot_count(data = data_filt)
```

```{r protein-counts}
r6$plot_protein_counts() 
```

```{r Protein Coverage}
barplot_cover(data = data_filt)+
  theme(legend.position = "none")
```

```{r valid-values}
r6$plot_protein_coverage()
```

```{r Normalized data distribution}
boxplot(data=data_filt)
```

```{r plot-dis}
r6$plot_distribution()
```

## Plots

```{r Missing data distribution}
densityplot(data=data_filt)
```

```{r plot-missval2}
r6$plot_missval_distribution()
```

```{r Plot Missing data}
barplot_missval(data=data_filt)
```

```{r plot-missval1}
r6$plot_missing_data()
```

```{r Plot imputation}
den_imput(data=data_filt)    
```

```{r plot-imputation}
r6$plot_imputation()
```

```{r Heatmap}
htmap(data = data_filt)
```

```{r plot-corr}
r6$plot_correlation_interactive()
```

## PCA

```{r PCA 1}
pca <- prcomp(t(mat(data= data_imput)), center = TRUE, scale = TRUE) 
      
## create a data.frame for the first 3 PC
pca_table <- data.frame(label = rownames(pca$x),
                        x = pca$x[, 1],
                        y = pca$x[, 2],
                        z = pca$x[, 3]) %>% 
  dplyr::left_join(exp_des, by = "label") %>% 
  group_by(condition)
 

pca_plot(data=pca_table)

```

```{r pca}
r6$plot_pca(view_3d = FALSE)
```

## Statistical Analysis

```{r Statistics t-test}
r6$define_tests()
tests <- c("rev_vs_dmso", "nw_vs_dmso")
r6$stat_t_test(
  data = r6$imputed_data,
  test = tests,
  fc = 1,
  alpha = 0.05
)
```

## Volcao Plot

```{r VOlcano}
data <- r6$stat_table%>% 
  ggplot2::ggplot(aes(x=rev_vs_dmso_fold_change,
                      y=-log10(rev_vs_dmso_p_val),
                      color=dplyr::case_when(rev_vs_dmso_fold_change > 1 & -log10(rev_vs_dmso_p_val) > 0.5 ~ "red",
                              rev_vs_dmso_fold_change < -1 & -log10(rev_vs_dmso_p_val) > 0.5 ~ "blue",
                              TRUE ~ "grey"))) +
  geom_point()+
  theme_cuc()+
  geom_hline(yintercept = 0.5, linetype="longdash")+
  geom_vline(xintercept = c(-1, 1), linetype="longdash")+
  scale_color_identity()+
  xlim(-7,NA)+
  labs(title= "Volcano plot", subtitle= "Rev VS Dmso", x="Fold change", y= "P-value")
print(data)
```

```{r plot-volcano}
r6$plot_volcano(test = tests, highlights_names = c("VCAN", "STAT3"))
```

## Significant Data

```{r Dataset significat}
sig <- significant(data=r6$stat_table, test = "rev_vs_dmso")
```

### Only Up-regulated

```{r Filter Significant Up}
up_down <- sig_up_down(data=sig, remove="Down")
```

# STRINGdb

### Nodes & Edges

```{r Create Nodes & Edges}
nodes <- nodes(data=up_down)

edges <- edges(data= nodes, score=0.4)
```

### Filter Nodes

```{r Filter Nodes Degree 0}
nodes <- filter_nodes (datanodes =nodes, data_edges = edges)
```

### Plot Network

```{r echart Network}
plot_net(datanode=nodes, dataedge=edges)
```

### From data to net

```{r All from nodes to network}
plot_all (
  data = r6$stat_table,
  test = "nw_vs_dmso",
  remove = "Down",
  score = 0.4,
  animation = FALSE,
  layout = "force",
  no_edge = TRUE
)
```

# INTACTdb

### IntAct PSICQUIC
PSICQUIC mi permette di accedere a diversi databases utilizzando una singola funzione. In questo caso ho considerato solo Intact perchè per BioGrid e IMEx dava gli stessi risultati. Infatti i db sono tutti strettamente correllati e dipendenti tra loro.

```{r Intact PSICQUIC}
genes <- sig %>%
  dplyr::filter(regulation == "down") %>%
  pull(gene_names)

intact_edge <- function(gene_vector) {
 intact_list <- rba_reactome_interactors_psicquic(genes, resource = "IntAct", details = TRUE)

  all_interactions <- purrr::map(.x = 1:length(gene_vector),
                                 .f = ~ intact_list$entities[[.x]])

  res <- purrr::map(.x = all_interactions, .f = ~ keep_only_if_present(.x)) %>%
    purrr::compact() %>%
    purrr::reduce(bind_rows) %>%
    dplyr::select(source, alias, score, accURL, evidences) %>%
    tidyr::drop_na() %>%
    dplyr::filter(source != alias)

  return(res)
}

keep_only_if_present <- function(lista) {
  n_interaction <- lista$count
  name_source <- lista$acc

  res <-
    purrr::map(
      .x = 1:n_interaction,
      .f = ~ lista$interactors[[.x]] %>% purrr::list_modify(source = name_source)
    ) %>%
    purrr::keep(~ all(.x$alias %in% pull(nodes, name)))

  return(res)
}

genes <- nodes %>% pull(name)

intact_edge(genes)

```

```{r CORUM}
library(OmnipathR)

complexes <- import_omnipath_complexes(resources = "CORUM") #Tutte le interactions di CORUM
query <- nodes$name #Dataset

complexes_query_genes_any <-
  unique(get_complex_genes(complexes, query,
                           total_match = FALSE)) #Tutte le interazioni che includono il mio dataset

edges_corum <-  complexes_query_genes_any %>%
  dplyr::select(name, components_genesymbols) %>%
  tidyr::separate_rows(components_genesymbols, sep = "_") %>%
  dplyr::filter(components_genesymbols %in% query) %>%
  dplyr::mutate(unique_names = paste0(name, "__", components_genesymbols)) %>%
  dplyr::distinct(unique_names, .keep_all = TRUE) %>%
  dplyr::select(name, components_genesymbols) %>%
  get_dupes(name) %>%
  dplyr::filter(dupe_count == 2) %>%
  tibble::rowid_to_column() %>%
  dplyr::mutate(nodi = if_else(gtools::odd(rowid), "nodo", "target")) %>%
  dplyr::select(name, nodi, components_genesymbols) %>%
  tidyr::pivot_wider(name, values_from = components_genesymbols, names_from = nodi) %>%
  dplyr::mutate(Value = 10) %>%
  dplyr::rename(Source = nodo, Target = target) %>%
  dplyr::select(Source, Target, Value)

 plot_net(datanode=nodes, dataedge=edges_corum) #Provo a plottare solo CORUM
```


```{r STRING+CORUM}
 edges_all <-  edges %>% dplyr::bind_rows(edges_corum) %>% 
   dplyr::mutate(color= if_else(Value==10, "red","green")) %>% as.data.frame() #Unisco CORUM a STRING
 

 nodes_corum <- edges_corum <-  complexes_query_genes_any %>%
   dplyr::select(components_genesymbols) %>% 
   tidyr::separate_rows(components_genesymbols, sep = "_") %>%
   dplyr::filter(components_genesymbols %in% query) %>% 
   dplyr::distinct(components_genesymbols, .keep_all = TRUE) %>% 
   dplyr::rename(name=components_genesymbols) %>% 
   merge(nodes) %>% 
   dplyr::mutate(grp="corum")
   
 
 nodes_all <- nodes %>% 
   dplyr::mutate(grp="string") %>% 
   dplyr::bind_rows(nodes_corum) %>% as.data.frame()

 
 #Dai parametri del grafico vado a modificare il colore degli edges
p <-echarts4r::e_charts(animation = FALSE) %>%
   echarts4r::e_graph(
     roam = TRUE,
     force = list(
       initLayout = "force",
       repulsion = 100,
       edgeLength = 30,
       layoutAnimation = FALSE
     ),
     autoCurveness = TRUE,
     emphasis = list(focus = "adjacency",
                     lineStyle = list(width = 10))
   ) %>%
   echarts4r::e_graph_nodes(
     nodes = nodes,
     names = name,
     value = value,
     size = size,
     category = grp
   ) %>%
   echarts4r::e_graph_edges(
     edges = edges_all,
     source = Source,
     target = Target,
     value = Value,
     size = Value
   ) %>%
   echarts4r::e_title("Network", "Up & Down Regulated") %>%
   echarts4r::e_tooltip()
 




# p[["x"]][["opts"]][["series"]][[1]][["links"]][[1]][["lineStyle"]] <- list(width =p[["x"]][["opts"]][["series"]][[1]][["links"]][[1]][["lineStyle"]][["width"]], color = "red")



n_edges <- nrow(edges_all)
color <- edges_all %>% pull(color)


all_opt <- p %>% purrr::pluck("x", "opts", "series") %>%
  purrr::chuck(1) %>%
  purrr::pluck("links") %>% View()

all_links <- p %>% purrr::map(.x = 1:n_edges,
  .f = ~ all_opt[[.x]])%>% 
  purrr::chuck(1) %>%  purrr::pluck("")

  list(width = all_links, color = color)


  
# color<- edges_all %>% dplyr::filter(Source==source, Target==target) %>% pull(color) ## se il filter non è una riga sola bisogna fare qualcosa

color_edge <- function(list, edges) {
  n_edges <- nrow(edges)
  for (i in 1:n_edges) {
    source <- 
      list[["x"]][["opts"]][["series"]][[1]][["links"]][[i]]$source
    target <-
      list[["x"]][["opts"]][["series"]][[1]][["links"]][[i]]$target
    color <-
      edge %>% dplyr::filter(Source == source, Target == target) %>% pull(color)
    
    list[["x"]][["opts"]][["series"]][[1]][["links"]][[i]][["lineStyle"]] <-
      list(width = list[["x"]][["opts"]][["series"]][[1]][["links"]][[i]][["lineStyle"]][["width"]], color = color)
    
  }
  
  return(list)
}

tidyr::expand_grid(target = c("gene1", "gene2", "gene3"), source = c("gene1", "gene2", "gene3")) %>% 
  dplyr::filter(target != source)

purrr::map(.x = 1:45, .f = ~ color_edge_single(list = p, edge = edges_all, index = .x))

color_edge_single <- function(list, edge, index) {
  
  source<- list[["x"]][["opts"]][["series"]][[1]][["links"]][[index]]$source
  target<- list[["x"]][["opts"]][["series"]][[1]][["links"]][[index]]$target
  
  
  list[["x"]][["opts"]][["series"]][[1]][["links"]][[index]][["lineStyle"]] <- 
    list(width =list[["x"]][["opts"]][["series"]][[1]][["links"]][[index]][["lineStyle"]][["width"]],
         color = color)
   
  return(list)
}


n_edges<- nrow(edges_all)
color_edge_single(p, edges_all, 2)

p2 <- color_edge(p, edges_all)
p2
  
nodes <- nodes %>%
  dplyr::mutate(color = if_else(value>2, "red", "blue"))
  View()
```

```{r}
a <- complexes_query_genes_any %>%
  dplyr::select(name, components_genesymbols) %>%
  tidyr::separate_rows(components_genesymbols, sep = "_") %>%
  dplyr::filter(components_genesymbols %in% query) %>%
  dplyr::mutate(unique_names = paste0(name, "__", components_genesymbols)) %>%
  dplyr::distinct(unique_names, .keep_all = TRUE) %>%
  dplyr::select(name, components_genesymbols) %>%
  get_dupes(name) %>%
  dplyr::filter(dupe_count > 2) %>% 
  pull(components_genesymbols) 

b <- tidyr::expand_grid(Target = a, Source = a) %>% 
  dplyr::filter(Target != Source) %>% 
  dplyr::mutate(Value = 10)

final_edge <- b %>% bind_rows(edges_corum)
```

```{r}
go_data <- data.table::fread("ora_table.tsv")

nodes_go <- go_data %>% 
  tidyr::separate_rows(geneID, sep = "/") %>% 
  dplyr::filter(group=="nw_vs_dmso_down") %>% 
  dplyr::mutate(name=paste0(Description, "_", geneID)) %>% 
  dplyr::select(Description, name, pvalue, p.adjust, qvalue, value=fold_change, grp=group) %>% 
    tidyr::separate_rows(name, sep = "_") %>% 
  dplyr::distinct(name, .keep_all = TRUE) %>% 
  dplyr::mutate(size=dplyr::if_else(Description==name, value, 10)) %>% 
  dplyr::mutate(symbol=dplyr::if_else(Description==name, "diamond", "circle")) %>% 
  dplyr::mutate(label=dplyr::if_else(Description==name, name, "")) %>% 
  dplyr::select(!Description)


edges_go <- go_data%>% 
  dplyr::filter(group== "nw_vs_dmso_down") %>% 
  dplyr::select(Description, pvalue, p.adjust, qvalue, fold_change, geneID) %>% 
  tidyr::separate_rows(geneID, sep = "/") %>% 
    dplyr::select(source=Description, target= geneID, value=pvalue) %>% 
  dplyr::mutate(size="1")
 

  echarts4r::e_charts() %>%
   echarts4r::e_graph(
     roam = TRUE,
     force = list(
       initLayout = "circular",
       repulsion = 500,
       edgeLength = 30,
       layoutAnimation = FALSE
     ),
     autoCurveness = TRUE,
     emphasis = list(focus = "adjacency",
                     lineStyle = list(width = 5))
   ) %>%
   echarts4r::e_graph_nodes(
     nodes = nodes_go,
     names = name,
     value = value,
     size = size,
     category = grp,
     symbol=symbol
   ) %>%
   echarts4r::e_graph_edges(
     edges = edges_go,
     source = source,
     target = target,
     value = value,
     size = size
   ) %>%
  #echarts4r::e_labels(nodes_go$label,font_size=4)%>%
   echarts4r::e_title("Network", "Gene Ontology") %>%
   echarts4r::e_tooltip()
  


```

